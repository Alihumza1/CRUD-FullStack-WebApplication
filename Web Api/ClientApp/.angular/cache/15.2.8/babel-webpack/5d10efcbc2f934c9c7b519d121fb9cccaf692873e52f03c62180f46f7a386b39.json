{"ast":null,"code":"import * as i1 from '@angular/common/http';\nimport { HttpRequest, HttpResponse, HttpHeaders, HttpParams } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, PLATFORM_ID, Inject, NgModule } from '@angular/core';\nimport { of, BehaviorSubject, isObservable, throwError, timer } from 'rxjs';\nimport { filter, map, retry, shareReplay, catchError, concatMap, take } from 'rxjs/operators';\nimport * as vlq from 'vlq';\nimport * as i1$1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\n\n/**\r\n * Injection token of logger config\r\n */\nconst TOKEN_LOGGER_CONFIG = 'TOKEN_LOGGER_CONFIG';\nclass NGXLoggerConfigEngine {\n  constructor(config) {\n    this.config = this._clone(config);\n  }\n  /** Get a readonly access to the level configured for the NGXLogger */\n  get level() {\n    return this.config.level;\n  }\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\n  get serverLogLevel() {\n    return this.config.serverLogLevel;\n  }\n  updateConfig(config) {\n    this.config = this._clone(config);\n  }\n  /** Update the config partially\r\n   * This is useful if you want to update only one parameter of the config\r\n   */\n  partialUpdateConfig(partialConfig) {\n    // avoid any error if the config is incorrect\n    if (!partialConfig) {\n      return;\n    }\n    Object.keys(partialConfig).forEach(configParamKey => {\n      this.config[configParamKey] = partialConfig[configParamKey];\n    });\n  }\n  getConfig() {\n    return this._clone(this.config);\n  }\n  // TODO: This is a shallow clone, If the config ever becomes hierarchical we must make this a deep clone\n  _clone(object) {\n    const cloneConfig = {\n      level: null\n    };\n    Object.keys(object).forEach(key => {\n      cloneConfig[key] = object[key];\n    });\n    return cloneConfig;\n  }\n}\n\n/**\r\n * Injection token of logger config engine factory\r\n */\nconst TOKEN_LOGGER_CONFIG_ENGINE_FACTORY = 'TOKEN_LOGGER_CONFIG_ENGINE_FACTORY';\nclass NGXLoggerConfigEngineFactory {\n  provideConfigEngine(config) {\n    return new NGXLoggerConfigEngine(config);\n  }\n}\n\n/**\r\n * Injection token of logger mapper service\r\n */\nconst TOKEN_LOGGER_MAPPER_SERVICE = 'TOKEN_LOGGER_MAPPER_SERVICE';\nclass NGXLoggerMapperService {\n  constructor(httpBackend) {\n    this.httpBackend = httpBackend;\n    /** cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map' */\n    this.sourceMapCache = new Map();\n    /** cache for specific log position, key is the dist position, ie 'main.js:339:21' */\n    this.logPositionCache = new Map();\n  }\n  /**\r\n   * Returns the log position of the caller\r\n   * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n   * @param config\r\n   * @param metadata\r\n   * @returns\r\n   */\n  getLogPosition(config, metadata) {\n    const stackLine = this.getStackLine(config);\n    // if we were not able to parse the stackLine, just return an empty Log Position\n    if (!stackLine) {\n      return of({\n        fileName: '',\n        lineNumber: 0,\n        columnNumber: 0\n      });\n    }\n    const logPosition = this.getLocalPosition(stackLine);\n    if (!config.enableSourceMaps) {\n      return of(logPosition);\n    }\n    const sourceMapLocation = this.getSourceMapLocation(stackLine);\n    return this.getSourceMap(sourceMapLocation, logPosition);\n  }\n  /**\r\n   * Get the stackline of the original caller\r\n   * @param config\r\n   * @returns null if stackline was not found\r\n   */\n  getStackLine(config) {\n    const error = new Error();\n    try {\n      // noinspection ExceptionCaughtLocallyJS\n      throw error;\n    } catch (e) {\n      try {\n        // Here are different examples of stacktrace \n        // Firefox (last line is the user code, the 4 first are ours):\n        // getStackLine@http://localhost:4200/main.js:358:23\n        // getCallerDetails@http://localhost:4200/main.js:557:44\n        // _log@http://localhost:4200/main.js:830:28\n        // debug@http://localhost:4200/main.js:652:14\n        // handleLog@http://localhost:4200/main.js:1158:29\n        // Chrome and Edge (last line is the user code):\n        // Error\n        // at Function.getStackLine (ngx-logger.js:329)\n        // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\n        // at NGXLogger._log (ngx-logger.js:801)\n        // at NGXLogger.info (ngx-logger.js:631)\n        // at AppComponent.handleLog (app.component.ts:38)\n        let defaultProxy = 4; // We make 4 functions call before getting here\n        const firstStackLine = error.stack.split('\\n')[0];\n        if (!firstStackLine.includes('.js:')) {\n          // The stacktrace starts with no function call (example in Chrome or Edge)\n          defaultProxy = defaultProxy + 1;\n        }\n        return error.stack.split('\\n')[defaultProxy + (config.proxiedSteps || 0)];\n      } catch (e) {\n        return null;\n      }\n    }\n  }\n  /**\r\n   * Get position of caller without using sourceMaps\r\n   * @param stackLine\r\n   * @returns\r\n   */\n  getLocalPosition(stackLine) {\n    // strip base path, then parse filename, line, and column, stackline looks like this :\n    // Firefox\n    // handleLog@http://localhost:4200/main.js:1158:29\n    // Chrome and Edge\n    // at AppComponent.handleLog (app.component.ts:38)\n    const positionStartIndex = stackLine.lastIndexOf('\\/');\n    let positionEndIndex = stackLine.indexOf(')');\n    if (positionEndIndex < 0) {\n      positionEndIndex = undefined;\n    }\n    const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\n    const dataArray = position.split(':');\n    if (dataArray.length === 3) {\n      return {\n        fileName: dataArray[0],\n        lineNumber: +dataArray[1],\n        columnNumber: +dataArray[2]\n      };\n    }\n    return {\n      fileName: 'unknown',\n      lineNumber: 0,\n      columnNumber: 0\n    };\n  }\n  getTranspileLocation(stackLine) {\n    // Example stackLine:\n    // Firefox : getStackLine@http://localhost:4200/main.js:358:23\n    // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\n    let locationStartIndex = stackLine.indexOf('(');\n    if (locationStartIndex < 0) {\n      locationStartIndex = stackLine.lastIndexOf('@');\n      if (locationStartIndex < 0) {\n        locationStartIndex = stackLine.lastIndexOf(' ');\n      }\n    }\n    let locationEndIndex = stackLine.indexOf(')');\n    if (locationEndIndex < 0) {\n      locationEndIndex = undefined;\n    }\n    return stackLine.substring(locationStartIndex + 1, locationEndIndex);\n  }\n  /**\r\n   * Gets the URL of the sourcemap (the URL can be relative or absolute, it is browser dependant)\r\n   * @param stackLine\r\n   * @returns\r\n   */\n  getSourceMapLocation(stackLine) {\n    const file = this.getTranspileLocation(stackLine);\n    const mapFullPath = file.substring(0, file.lastIndexOf(':'));\n    return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\n  }\n  getMapping(sourceMap, position) {\n    // => ';' indicates end of a line\n    // => ',' separates mappings in a line\n    // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\n    let sourceFileIndex = 0,\n      // second field\n      sourceCodeLine = 0,\n      // third field\n      sourceCodeColumn = 0; // fourth field\n    const lines = sourceMap.mappings.split(';');\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      // reset column position to 0 after each line\n      let generatedCodeColumn = 0;\n      // decode sections in line\n      const columns = lines[lineIndex].split(',');\n      for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\n        const decodedSection = vlq.decode(columns[columnIndex]);\n        if (decodedSection.length >= 4) {\n          // update relative positions\n          generatedCodeColumn += decodedSection[0];\n          sourceFileIndex += decodedSection[1];\n          sourceCodeLine += decodedSection[2];\n          sourceCodeColumn += decodedSection[3];\n        }\n        // check if matching map\n        if (lineIndex === position.lineNumber) {\n          if (generatedCodeColumn === position.columnNumber) {\n            // matching column and line found\n            return {\n              fileName: sourceMap.sources[sourceFileIndex],\n              lineNumber: sourceCodeLine,\n              columnNumber: sourceCodeColumn\n            };\n          } else if (columnIndex + 1 === columns.length) {\n            // matching column not found, but line is correct\n            return {\n              fileName: sourceMap.sources[sourceFileIndex],\n              lineNumber: sourceCodeLine,\n              columnNumber: 0\n            };\n          }\n        }\n      }\n    }\n    // failed if reached\n    return {\n      fileName: 'unknown',\n      lineNumber: 0,\n      columnNumber: 0\n    };\n  }\n  /**\r\n   * does the http get request to get the source map\r\n   * @param sourceMapLocation\r\n   * @param distPosition\r\n   */\n  getSourceMap(sourceMapLocation, distPosition) {\n    const req = new HttpRequest('GET', sourceMapLocation);\n    const distPositionKey = `${distPosition.fileName}:${distPosition.lineNumber}:${distPosition.columnNumber}`;\n    // if the specific log position is already in cache return it\n    if (this.logPositionCache.has(distPositionKey)) {\n      return this.logPositionCache.get(distPositionKey);\n    }\n    // otherwise check if the source map is already cached for given source map location\n    if (!this.sourceMapCache.has(sourceMapLocation)) {\n      if (!this.httpBackend) {\n        console.error('NGXLogger : Can\\'t get sourcemap because HttpBackend is not provided. You need to import HttpClientModule');\n        this.sourceMapCache.set(sourceMapLocation, of(null));\n      } else {\n        // obtain the source map if not cached\n        this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter(e => e instanceof HttpResponse), map(httpResponse => httpResponse.body), retry(3), shareReplay(1)));\n      }\n    }\n    // at this point the source map is cached, use it to get specific log position mapping\n    const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map(sourceMap => {\n      // sourceMap can be null if HttpBackend is not provided for example\n      if (!sourceMap) {\n        return distPosition;\n      }\n      // map generated position to source position\n      return this.getMapping(sourceMap, distPosition);\n    }), catchError(() => of(distPosition)), shareReplay(1));\n    // store specific log position in cache for given dest position and return it\n    this.logPositionCache.set(distPositionKey, logPosition$);\n    return logPosition$;\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerMapperService.ɵfac = function NGXLoggerMapperService_Factory(t) {\n  return new (t || NGXLoggerMapperService)(i0.ɵɵinject(i1.HttpBackend, 8));\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerMapperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerMapperService,\n  factory: NGXLoggerMapperService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMapperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpBackend,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\n/**\r\n * Injection token of logger metadata service\r\n */\nconst TOKEN_LOGGER_METADATA_SERVICE = 'TOKEN_LOGGER_METADATA_SERVICE';\nclass NGXLoggerMetadataService {\n  constructor(datePipe) {\n    this.datePipe = datePipe;\n  }\n  computeTimestamp(config) {\n    const defaultTimestamp = () => new Date().toISOString();\n    if (config.timestampFormat) {\n      if (!this.datePipe) {\n        console.error('NGXLogger : Can\\'t use timeStampFormat because DatePipe is not provided. You need to provide DatePipe');\n        return defaultTimestamp();\n      } else {\n        return this.datePipe.transform(new Date(), config.timestampFormat);\n      }\n    }\n    return defaultTimestamp();\n  }\n  getMetadata(level, config, message, additional) {\n    const metadata = {\n      level: level,\n      additional: additional\n    };\n    // The user can send a function\n    // This is useful in order to compute string concatenation only when the log will actually be written\n    if (message && typeof message === 'function') {\n      metadata.message = message();\n    } else {\n      metadata.message = message;\n    }\n    metadata.timestamp = this.computeTimestamp(config);\n    return metadata;\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerMetadataService.ɵfac = function NGXLoggerMetadataService_Factory(t) {\n  return new (t || NGXLoggerMetadataService)(i0.ɵɵinject(i1$1.DatePipe, 8));\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerMetadataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerMetadataService,\n  factory: NGXLoggerMetadataService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMetadataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1$1.DatePipe,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\n// I kept this class alive only to avoid a breaking change with the old version\n// This class does not implement anything so it is useless and the interface is enough\n/**\r\n * @deprecated this class does not implement anything thus being useless, you should rather implements @see INGXLoggerMonitor\r\n */\nclass NGXLoggerMonitor {}\n\n/**\r\n * Injection token of logger metadata service\r\n */\nconst TOKEN_LOGGER_RULES_SERVICE = 'TOKEN_LOGGER_RULES_SERVICE';\nclass NGXLoggerRulesService {\n  shouldCallWriter(level, config, message, additional) {\n    return !config.disableConsoleLogging && level >= config.level;\n  }\n  shouldCallServer(level, config, message, additional) {\n    return !!config.serverLoggingUrl && level >= config.serverLogLevel;\n  }\n  shouldCallMonitor(level, config, message, additional) {\n    // The default behavior is to call the monitor only if the writer or the server is called\n    return this.shouldCallWriter(level, config, message, additional) || this.shouldCallServer(level, config, message, additional);\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerRulesService.ɵfac = function NGXLoggerRulesService_Factory(t) {\n  return new (t || NGXLoggerRulesService)();\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerRulesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerRulesService,\n  factory: NGXLoggerRulesService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerRulesService, [{\n    type: Injectable\n  }], null, null);\n})();\n\n/**\r\n * Injection token of logger server service\r\n */\nconst TOKEN_LOGGER_SERVER_SERVICE = 'TOKEN_LOGGER_SERVER_SERVICE';\nclass NGXLoggerServerService {\n  constructor(httpBackend, ngZone) {\n    this.httpBackend = httpBackend;\n    this.ngZone = ngZone;\n    this.serverCallsQueue = [];\n    this.flushingQueue = new BehaviorSubject(false);\n  }\n  ngOnDestroy() {\n    if (this.flushingQueue) {\n      this.flushingQueue.complete();\n      this.flushingQueue = null;\n    }\n    if (this.addToQueueTimer) {\n      this.addToQueueTimer.unsubscribe();\n      this.addToQueueTimer = null;\n    }\n  }\n  /**\r\n   * Transforms an error object into a readable string (taking only the stack)\r\n   * This is needed because JSON.stringify would return \"{}\"\r\n   * @param err the error object\r\n   * @returns The stack of the error\r\n   */\n  secureErrorObject(err) {\n    return err?.stack;\n  }\n  /**\r\n   * Transforms the additional parameters to avoid any json error when sending the data to the server\r\n   * Basically it just replaces unstringifiable object to a string mentioning an error\r\n   * @param additional The additional data to be sent\r\n   * @returns The additional data secured\r\n   */\n  secureAdditionalParameters(additional) {\n    if (additional === null || additional === undefined) {\n      return null;\n    }\n    return additional.map((next, idx) => {\n      try {\n        if (next instanceof Error) {\n          return this.secureErrorObject(next);\n        }\n        // We just want to make sure the JSON can be parsed, we do not want to actually change the type\n        if (typeof next === 'object') {\n          JSON.stringify(next);\n        }\n        return next;\n      } catch (e) {\n        return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\n      }\n    });\n  }\n  /**\r\n   * Transforms the message so that it can be sent to the server\r\n   * @param message the message to be sent\r\n   * @returns the message secured\r\n   */\n  secureMessage(message) {\n    try {\n      if (message instanceof Error) {\n        return this.secureErrorObject(message);\n      }\n      if (typeof message !== 'string') {\n        message = JSON.stringify(message, null, 2);\n      }\n    } catch (e) {\n      message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\n    }\n    return message;\n  }\n  /**\r\n   * Edits HttpRequest object before sending request to server\r\n   * @param httpRequest default request object\r\n   * @returns altered httprequest\r\n   */\n  alterHttpRequest(httpRequest) {\n    return httpRequest;\n  }\n  /**\r\n   * Sends request to server\r\n   * @param url\r\n   * @param logContent\r\n   * @param options\r\n   * @returns\r\n   */\n  logOnServer(url, logContent, options) {\n    if (!this.httpBackend) {\n      console.error('NGXLogger : Can\\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');\n      return of(null);\n    }\n    // HttpBackend skips all HttpInterceptors\n    // They may log errors using this service causing circular calls\n    let defaultRequest = new HttpRequest('POST', url, logContent, options || {});\n    let finalRequest = of(defaultRequest);\n    const alteredRequest = this.alterHttpRequest(defaultRequest);\n    if (isObservable(alteredRequest)) {\n      finalRequest = alteredRequest;\n    } else if (alteredRequest) {\n      finalRequest = of(alteredRequest);\n    } else {\n      console.warn('NGXLogger : alterHttpRequest returned an invalid request. Using default one instead');\n    }\n    return finalRequest.pipe(concatMap(req => {\n      if (!req) {\n        console.warn('NGXLogger : alterHttpRequest returned an invalid request (observable). Using default one instead');\n        return this.httpBackend.handle(defaultRequest);\n      }\n      return this.httpBackend.handle(req);\n    }), filter(e => e instanceof HttpResponse), map(httpResponse => httpResponse.body));\n  }\n  /**\r\n   * Customise the data sent to the API\r\n   * @param metadata the data provided by NGXLogger\r\n   * @returns the data that will be sent to the API in the body\r\n   */\n  customiseRequestBody(metadata) {\n    // In our API the body is not customised\n    return metadata;\n  }\n  /**\r\n   * Flush the queue of the logger\r\n   * @param config\r\n   */\n  flushQueue(config) {\n    this.flushingQueue.next(true);\n    // If a timer was set, we cancel it because the queue is flushed\n    if (this.addToQueueTimer) {\n      this.addToQueueTimer.unsubscribe();\n      this.addToQueueTimer = null;\n    }\n    if (!!this.serverCallsQueue && this.serverCallsQueue.length > 0) {\n      this.sendToServerAction(this.serverCallsQueue, config);\n    }\n    this.serverCallsQueue = [];\n    this.flushingQueue.next(false);\n  }\n  sendToServerAction(metadata, config) {\n    let requestBody;\n    const secureMetadata = pMetadata => {\n      // Copying metadata locally because we don't want to change the object for the caller\n      const securedMetadata = {\n        ...pMetadata\n      };\n      securedMetadata.additional = this.secureAdditionalParameters(securedMetadata.additional);\n      securedMetadata.message = this.secureMessage(securedMetadata.message);\n      return securedMetadata;\n    };\n    if (Array.isArray(metadata)) {\n      requestBody = [];\n      metadata.forEach(m => {\n        requestBody.push(secureMetadata(m));\n      });\n    } else {\n      requestBody = secureMetadata(metadata);\n    }\n    // Allow users to customise the data sent to the API\n    requestBody = this.customiseRequestBody(requestBody);\n    const headers = config.customHttpHeaders || new HttpHeaders();\n    if (!headers.has('Content-Type')) {\n      headers.set('Content-Type', 'application/json');\n    }\n    const logOnServerAction = () => {\n      this.logOnServer(config.serverLoggingUrl, requestBody, {\n        headers,\n        params: config.customHttpParams || new HttpParams(),\n        responseType: config.httpResponseType || 'json',\n        withCredentials: config.withCredentials || false\n      }).pipe(catchError(err => {\n        // Do not use NGXLogger here because this could cause an infinite loop \n        console.error('NGXLogger: Failed to log on server', err);\n        return throwError(err);\n      })).subscribe();\n    };\n    if (config.serverCallsOutsideNgZone === true) {\n      if (!this.ngZone) {\n        console.error('NGXLogger: NgZone is not provided and serverCallsOutsideNgZone is set to true');\n        return;\n      }\n      this.ngZone.runOutsideAngular(logOnServerAction);\n    } else {\n      logOnServerAction();\n    }\n  }\n  /**\r\n   * Sends the content to be logged to the server according to the config\r\n   * @param metadata\r\n   * @param config\r\n   */\n  sendToServer(metadata, config) {\n    // If there is no batch mode in the config, we send the log call straight to the server as usual\n    if ((!config.serverCallsBatchSize || config.serverCallsBatchSize <= 0) && (!config.serverCallsTimer || config.serverCallsTimer <= 0)) {\n      this.sendToServerAction(metadata, config);\n      return;\n    }\n    const addLogToQueueAction = () => {\n      this.serverCallsQueue.push({\n        ...metadata\n      });\n      // Flush queue when size is reached\n      if (!!config.serverCallsBatchSize && this.serverCallsQueue.length > config.serverCallsBatchSize) {\n        this.flushQueue(config);\n      }\n      // Call timer only if it is in the config and timer is not already running\n      if (config.serverCallsTimer > 0 && !this.addToQueueTimer) {\n        this.addToQueueTimer = timer(config.serverCallsTimer).subscribe(_ => {\n          this.flushQueue(config);\n        });\n      }\n    };\n    // If queue is being flushed, we need to wait for it to finish before adding other calls\n    if (this.flushingQueue.value === true) {\n      this.flushingQueue.pipe(filter(fq => fq === false), take(1)).subscribe(_ => {\n        addLogToQueueAction();\n      });\n    } else {\n      addLogToQueueAction();\n    }\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerServerService.ɵfac = function NGXLoggerServerService_Factory(t) {\n  return new (t || NGXLoggerServerService)(i0.ɵɵinject(i1.HttpBackend, 8), i0.ɵɵinject(i0.NgZone, 8));\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerServerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerServerService,\n  factory: NGXLoggerServerService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerServerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpBackend,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: i0.NgZone,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\n/**\r\n * Injection token of logger writer service\r\n */\nconst TOKEN_LOGGER_WRITER_SERVICE = 'TOKEN_LOGGER_WRITER_SERVICE';\nvar NgxLoggerLevel;\n(function (NgxLoggerLevel) {\n  NgxLoggerLevel[NgxLoggerLevel[\"TRACE\"] = 0] = \"TRACE\";\n  NgxLoggerLevel[NgxLoggerLevel[\"DEBUG\"] = 1] = \"DEBUG\";\n  NgxLoggerLevel[NgxLoggerLevel[\"INFO\"] = 2] = \"INFO\";\n  NgxLoggerLevel[NgxLoggerLevel[\"LOG\"] = 3] = \"LOG\";\n  NgxLoggerLevel[NgxLoggerLevel[\"WARN\"] = 4] = \"WARN\";\n  NgxLoggerLevel[NgxLoggerLevel[\"ERROR\"] = 5] = \"ERROR\";\n  NgxLoggerLevel[NgxLoggerLevel[\"FATAL\"] = 6] = \"FATAL\";\n  NgxLoggerLevel[NgxLoggerLevel[\"OFF\"] = 7] = \"OFF\";\n})(NgxLoggerLevel || (NgxLoggerLevel = {}));\nconst DEFAULT_COLOR_SCHEME = ['purple', 'teal', 'gray', 'gray', 'red', 'red', 'red'];\nclass NGXLoggerWriterService {\n  constructor(platformId) {\n    this.platformId = platformId;\n    /** List of functions called when preparing meta string */\n    this.prepareMetaStringFuncs = [this.getTimestampToWrite, this.getLevelToWrite, this.getFileDetailsToWrite, this.getContextToWrite];\n    this.isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent && !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\n    this.logFunc = this.isIE ? this.logIE.bind(this) : this.logModern.bind(this);\n  }\n  getTimestampToWrite(metadata, config) {\n    return metadata.timestamp;\n  }\n  getLevelToWrite(metadata, config) {\n    return NgxLoggerLevel[metadata.level];\n  }\n  getFileDetailsToWrite(metadata, config) {\n    return config.disableFileDetails === true ? '' : `[${metadata.fileName}:${metadata.lineNumber}:${metadata.columnNumber}]`;\n  }\n  getContextToWrite(metadata, config) {\n    return config.context ? `{${config.context}}` : '';\n  }\n  /** Generate a \"meta\" string that is displayed before the content sent to the log function */\n  prepareMetaString(metadata, config) {\n    let metaString = '';\n    this.prepareMetaStringFuncs.forEach(prepareMetaStringFunc => {\n      const metaItem = prepareMetaStringFunc(metadata, config);\n      if (metaItem) {\n        metaString = metaString + ' ' + metaItem;\n      }\n    });\n    return metaString.trim();\n  }\n  /** Get the color to use when writing to console */\n  getColor(metadata, config) {\n    const configColorScheme = config.colorScheme ?? DEFAULT_COLOR_SCHEME;\n    // this is needed to avoid a build error\n    if (metadata.level === NgxLoggerLevel.OFF) {\n      return undefined;\n    }\n    return configColorScheme[metadata.level];\n  }\n  /** Log to the console specifically for IE */\n  logIE(metadata, config, metaString) {\n    // Coloring doesn't work in IE\n    // make sure additional isn't null or undefined so that ...additional doesn't error\n    const additional = metadata.additional || [];\n    switch (metadata.level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`${metaString} `, metadata.message, ...additional);\n        break;\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`${metaString} `, metadata.message, ...additional);\n        break;\n      case NgxLoggerLevel.INFO:\n        console.info(`${metaString} `, metadata.message, ...additional);\n        break;\n      default:\n        console.log(`${metaString} `, metadata.message, ...additional);\n    }\n  }\n  /** Log to the console */\n  logModern(metadata, config, metaString) {\n    const color = this.getColor(metadata, config);\n    // make sure additional isn't null or undefined so that ...additional doesn't error\n    const additional = metadata.additional || [];\n    switch (metadata.level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n      case NgxLoggerLevel.INFO:\n        console.info(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n      //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\n      // the console.trace statement\n      // case NgxLoggerLevel.TRACE:\n      //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\n      //   break;\n      case NgxLoggerLevel.DEBUG:\n        console.debug(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n      default:\n        console.log(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n    }\n  }\n  /** Write the content sent to the log function to the console */\n  writeMessage(metadata, config) {\n    const metaString = this.prepareMetaString(metadata, config);\n    this.logFunc(metadata, config, metaString);\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerWriterService.ɵfac = function NGXLoggerWriterService_Factory(t) {\n  return new (t || NGXLoggerWriterService)(i0.ɵɵinject(PLATFORM_ID));\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerWriterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerWriterService,\n  factory: NGXLoggerWriterService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerWriterService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\nclass NGXLogger {\n  constructor(config, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\n    this.metadataService = metadataService;\n    this.ruleService = ruleService;\n    this.mapperService = mapperService;\n    this.writerService = writerService;\n    this.serverService = serverService;\n    this.configEngine = configEngineFactory.provideConfigEngine(config);\n  }\n  /** Get a readonly access to the level configured for the NGXLogger */\n  get level() {\n    return this.configEngine.level;\n  }\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\n  get serverLogLevel() {\n    return this.configEngine.serverLogLevel;\n  }\n  trace(message, ...additional) {\n    this._log(NgxLoggerLevel.TRACE, message, additional);\n  }\n  debug(message, ...additional) {\n    this._log(NgxLoggerLevel.DEBUG, message, additional);\n  }\n  info(message, ...additional) {\n    this._log(NgxLoggerLevel.INFO, message, additional);\n  }\n  log(message, ...additional) {\n    this._log(NgxLoggerLevel.LOG, message, additional);\n  }\n  warn(message, ...additional) {\n    this._log(NgxLoggerLevel.WARN, message, additional);\n  }\n  error(message, ...additional) {\n    this._log(NgxLoggerLevel.ERROR, message, additional);\n  }\n  fatal(message, ...additional) {\n    this._log(NgxLoggerLevel.FATAL, message, additional);\n  }\n  /** @deprecated customHttpHeaders is now part of the config, this should be updated via @see updateConfig */\n  setCustomHttpHeaders(headers) {\n    const config = this.getConfigSnapshot();\n    config.customHttpHeaders = headers;\n    this.updateConfig(config);\n  }\n  /** @deprecated customHttpParams is now part of the config, this should be updated via @see updateConfig */\n  setCustomParams(params) {\n    const config = this.getConfigSnapshot();\n    config.customHttpParams = params;\n    this.updateConfig(config);\n  }\n  /** @deprecated withCredentials is now part of the config, this should be updated via @see updateConfig */\n  setWithCredentialsOptionValue(withCredentials) {\n    const config = this.getConfigSnapshot();\n    config.withCredentials = withCredentials;\n    this.updateConfig(config);\n  }\n  /**\r\n   * Register a INGXLoggerMonitor that will be trigger when a log is either written or sent to server\r\n   *\r\n   * There is only one monitor, registering one will overwrite the last one if there was one\r\n   * @param monitor\r\n   */\n  registerMonitor(monitor) {\n    this._loggerMonitor = monitor;\n  }\n  /** Set config of logger\r\n   *\r\n   * Warning : This overwrites all the config, if you want to update only one property, you should use @see getConfigSnapshot before\r\n   */\n  updateConfig(config) {\n    this.configEngine.updateConfig(config);\n  }\n  partialUpdateConfig(partialConfig) {\n    this.configEngine.partialUpdateConfig(partialConfig);\n  }\n  /** Get config of logger */\n  getConfigSnapshot() {\n    return this.configEngine.getConfig();\n  }\n  /**\r\n   * Flush the serveur queue\r\n   */\n  flushServerQueue() {\n    this.serverService.flushQueue(this.getConfigSnapshot());\n  }\n  _log(level, message, additional = []) {\n    const config = this.configEngine.getConfig();\n    const shouldCallWriter = this.ruleService.shouldCallWriter(level, config, message, additional);\n    const shouldCallServer = this.ruleService.shouldCallServer(level, config, message, additional);\n    const shouldCallMonitor = this.ruleService.shouldCallMonitor(level, config, message, additional);\n    if (!shouldCallWriter && !shouldCallServer && !shouldCallMonitor) {\n      // If nothing is to be called we return\n      return;\n    }\n    const metadata = this.metadataService.getMetadata(level, config, message, additional);\n    this.mapperService.getLogPosition(config, metadata).pipe(take(1)).subscribe(logPosition => {\n      if (logPosition) {\n        metadata.fileName = logPosition.fileName;\n        metadata.lineNumber = logPosition.lineNumber;\n        metadata.columnNumber = logPosition.columnNumber;\n      }\n      if (shouldCallMonitor && this._loggerMonitor) {\n        this._loggerMonitor.onLog(metadata, config);\n      }\n      if (shouldCallWriter) {\n        this.writerService.writeMessage(metadata, config);\n      }\n      if (shouldCallServer) {\n        this.serverService.sendToServer(metadata, config);\n      }\n    });\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLogger.ɵfac = function NGXLogger_Factory(t) {\n  return new (t || NGXLogger)(i0.ɵɵinject(TOKEN_LOGGER_CONFIG), i0.ɵɵinject(TOKEN_LOGGER_CONFIG_ENGINE_FACTORY), i0.ɵɵinject(TOKEN_LOGGER_METADATA_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_RULES_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_MAPPER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_WRITER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_SERVER_SERVICE));\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLogger.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLogger,\n  factory: NGXLogger.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLogger, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_METADATA_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_RULES_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_MAPPER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_WRITER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_SERVER_SERVICE]\n      }]\n    }];\n  }, null);\n})();\n\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n */\nclass CustomNGXLoggerService {\n  constructor(logger, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\n    this.logger = logger;\n    this.configEngineFactory = configEngineFactory;\n    this.metadataService = metadataService;\n    this.ruleService = ruleService;\n    this.mapperService = mapperService;\n    this.writerService = writerService;\n    this.serverService = serverService;\n  }\n  /**\r\n   * Create an instance of a logger\r\n   * @deprecated this function does not have all the features, @see getNewInstance for every params available\r\n   * @param config\r\n   * @param serverService\r\n   * @param logMonitor\r\n   * @param mapperService\r\n   * @returns\r\n   */\n  create(config, serverService, logMonitor, mapperService) {\n    return this.getNewInstance({\n      config,\n      serverService,\n      logMonitor,\n      mapperService\n    });\n  }\n  /**\r\n   * Get a new instance of NGXLogger\r\n   * @param params list of optional params to use when creating an instance of NGXLogger\r\n   * @returns the new instance of NGXLogger\r\n   */\n  getNewInstance(params) {\n    const logger = new NGXLogger(params?.config ?? this.logger.getConfigSnapshot(), params?.configEngineFactory ?? this.configEngineFactory, params?.metadataService ?? this.metadataService, params?.ruleService ?? this.ruleService, params?.mapperService ?? this.mapperService, params?.writerService ?? this.writerService, params?.serverService ?? this.serverService);\n    if (params?.partialConfig) {\n      logger.partialUpdateConfig(params.partialConfig);\n    }\n    if (params?.logMonitor) {\n      logger.registerMonitor(params.logMonitor);\n    }\n    return logger;\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nCustomNGXLoggerService.ɵfac = function CustomNGXLoggerService_Factory(t) {\n  return new (t || CustomNGXLoggerService)(i0.ɵɵinject(NGXLogger), i0.ɵɵinject(TOKEN_LOGGER_CONFIG_ENGINE_FACTORY), i0.ɵɵinject(TOKEN_LOGGER_METADATA_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_RULES_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_MAPPER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_WRITER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_SERVER_SERVICE));\n};\n/** @nocollapse */ /** @nocollapse */\nCustomNGXLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CustomNGXLoggerService,\n  factory: CustomNGXLoggerService.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CustomNGXLoggerService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: NGXLogger\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_METADATA_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_RULES_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_MAPPER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_WRITER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_SERVER_SERVICE]\n      }]\n    }];\n  }, null);\n})();\nclass LoggerModule {\n  static forRoot(config, customProvider) {\n    if (!customProvider) {\n      customProvider = {};\n    }\n    // default config provider\n    if (!customProvider.configProvider) {\n      customProvider.configProvider = {\n        provide: TOKEN_LOGGER_CONFIG,\n        useValue: config || {}\n      };\n    } else {\n      // if the user provided its own config, we just make sure the injection token is correct\n      if (customProvider.configProvider.provide !== TOKEN_LOGGER_CONFIG) {\n        throw new Error(`Wrong injection token for configProvider, it should be ${TOKEN_LOGGER_CONFIG} and you used ${customProvider.configProvider.provide}`);\n      }\n    }\n    // default configEngine provider\n    if (!customProvider.configEngineFactoryProvider) {\n      customProvider.configEngineFactoryProvider = {\n        provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY,\n        useClass: NGXLoggerConfigEngineFactory\n      };\n    } else {\n      // if the user provided its own configEngineFactory, we just make sure the injection token is correct\n      if (customProvider.configEngineFactoryProvider.provide !== TOKEN_LOGGER_CONFIG_ENGINE_FACTORY) {\n        throw new Error(`Wrong injection token for configEngineFactoryProvider, it should be '${TOKEN_LOGGER_CONFIG_ENGINE_FACTORY}' and you used '${customProvider.configEngineFactoryProvider.provide}'`);\n      }\n    }\n    // default metadata provider\n    if (!customProvider.metadataProvider) {\n      customProvider.metadataProvider = {\n        provide: TOKEN_LOGGER_METADATA_SERVICE,\n        useClass: NGXLoggerMetadataService\n      };\n    } else {\n      // if the user provided its own metadataService, we just make sure the injection token is correct\n      if (customProvider.metadataProvider.provide !== TOKEN_LOGGER_METADATA_SERVICE) {\n        throw new Error(`Wrong injection token for metadataProvider, it should be '${TOKEN_LOGGER_METADATA_SERVICE}' and you used '${customProvider.metadataProvider.provide}'`);\n      }\n    }\n    // default rule provider\n    if (!customProvider.ruleProvider) {\n      customProvider.ruleProvider = {\n        provide: TOKEN_LOGGER_RULES_SERVICE,\n        useClass: NGXLoggerRulesService\n      };\n    } else {\n      // if the user provided its own ruleService, we just make sure the injection token is correct\n      if (customProvider.ruleProvider.provide !== TOKEN_LOGGER_RULES_SERVICE) {\n        throw new Error(`Wrong injection token for ruleProvider, it should be '${TOKEN_LOGGER_RULES_SERVICE}' and you used '${customProvider.ruleProvider.provide}'`);\n      }\n    }\n    // default mapper provider\n    if (!customProvider.mapperProvider) {\n      customProvider.mapperProvider = {\n        provide: TOKEN_LOGGER_MAPPER_SERVICE,\n        useClass: NGXLoggerMapperService\n      };\n    } else {\n      // if the user provided its own mapperService, we just make sure the injection token is correct\n      if (customProvider.mapperProvider.provide !== TOKEN_LOGGER_MAPPER_SERVICE) {\n        throw new Error(`Wrong injection token for mapperProvider, it should be '${TOKEN_LOGGER_MAPPER_SERVICE}' and you used '${customProvider.mapperProvider.provide}'`);\n      }\n    }\n    // default writer provider\n    if (!customProvider.writerProvider) {\n      customProvider.writerProvider = {\n        provide: TOKEN_LOGGER_WRITER_SERVICE,\n        useClass: NGXLoggerWriterService\n      };\n    } else {\n      // if the user provided its own writerService, we just make sure the injection token is correct\n      if (customProvider.writerProvider.provide !== TOKEN_LOGGER_WRITER_SERVICE) {\n        throw new Error(`Wrong injection token for writerProvider, it should be '${TOKEN_LOGGER_WRITER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\n      }\n    }\n    // default server provider\n    if (!customProvider.serverProvider) {\n      customProvider.serverProvider = {\n        provide: TOKEN_LOGGER_SERVER_SERVICE,\n        useClass: NGXLoggerServerService\n      };\n    } else {\n      // if the user provided its own serverService, we just make sure the injection token is correct\n      if (customProvider.serverProvider.provide !== TOKEN_LOGGER_SERVER_SERVICE) {\n        throw new Error(`Wrong injection token for serverProvider, it should be '${TOKEN_LOGGER_SERVER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\n      }\n    }\n    return {\n      ngModule: LoggerModule,\n      providers: [NGXLogger, customProvider.configProvider, customProvider.configEngineFactoryProvider, customProvider.metadataProvider, customProvider.ruleProvider, customProvider.mapperProvider, customProvider.writerProvider, customProvider.serverProvider, CustomNGXLoggerService]\n    };\n  }\n  static forChild() {\n    // todo : this forChild is useless for now because nothing is different from forRoot.\n    // This should be implemented so that user can change the providers in the forChild\n    return {\n      ngModule: LoggerModule\n    };\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nLoggerModule.ɵfac = function LoggerModule_Factory(t) {\n  return new (t || LoggerModule)();\n};\n/** @nocollapse */ /** @nocollapse */\nLoggerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LoggerModule\n});\n/** @nocollapse */ /** @nocollapse */\nLoggerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoggerModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule]\n    }]\n  }], null, null);\n})();\n\n/*\r\n * Public API Surface of ngx-logger\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, LoggerModule, NGXLogger, NGXLoggerConfigEngine, NGXLoggerConfigEngineFactory, NGXLoggerMapperService, NGXLoggerMetadataService, NGXLoggerMonitor, NGXLoggerRulesService, NGXLoggerServerService, NGXLoggerWriterService, NgxLoggerLevel, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE };","map":{"version":3,"names":["i1","HttpRequest","HttpResponse","HttpHeaders","HttpParams","i0","Injectable","Optional","PLATFORM_ID","Inject","NgModule","of","BehaviorSubject","isObservable","throwError","timer","filter","map","retry","shareReplay","catchError","concatMap","take","vlq","i1$1","isPlatformBrowser","CommonModule","TOKEN_LOGGER_CONFIG","NGXLoggerConfigEngine","constructor","config","_clone","level","serverLogLevel","updateConfig","partialUpdateConfig","partialConfig","Object","keys","forEach","configParamKey","getConfig","object","cloneConfig","key","TOKEN_LOGGER_CONFIG_ENGINE_FACTORY","NGXLoggerConfigEngineFactory","provideConfigEngine","TOKEN_LOGGER_MAPPER_SERVICE","NGXLoggerMapperService","httpBackend","sourceMapCache","Map","logPositionCache","getLogPosition","metadata","stackLine","getStackLine","fileName","lineNumber","columnNumber","logPosition","getLocalPosition","enableSourceMaps","sourceMapLocation","getSourceMapLocation","getSourceMap","error","Error","e","defaultProxy","firstStackLine","stack","split","includes","proxiedSteps","positionStartIndex","lastIndexOf","positionEndIndex","indexOf","undefined","position","substring","dataArray","length","getTranspileLocation","locationStartIndex","locationEndIndex","file","mapFullPath","getMapping","sourceMap","sourceFileIndex","sourceCodeLine","sourceCodeColumn","lines","mappings","lineIndex","generatedCodeColumn","columns","columnIndex","decodedSection","decode","sources","distPosition","req","distPositionKey","has","get","console","set","handle","pipe","httpResponse","body","logPosition$","ɵfac","HttpBackend","ɵprov","type","decorators","TOKEN_LOGGER_METADATA_SERVICE","NGXLoggerMetadataService","datePipe","computeTimestamp","defaultTimestamp","Date","toISOString","timestampFormat","transform","getMetadata","message","additional","timestamp","DatePipe","NGXLoggerMonitor","TOKEN_LOGGER_RULES_SERVICE","NGXLoggerRulesService","shouldCallWriter","disableConsoleLogging","shouldCallServer","serverLoggingUrl","shouldCallMonitor","TOKEN_LOGGER_SERVER_SERVICE","NGXLoggerServerService","ngZone","serverCallsQueue","flushingQueue","ngOnDestroy","complete","addToQueueTimer","unsubscribe","secureErrorObject","err","secureAdditionalParameters","next","idx","JSON","stringify","secureMessage","alterHttpRequest","httpRequest","logOnServer","url","logContent","options","defaultRequest","finalRequest","alteredRequest","warn","customiseRequestBody","flushQueue","sendToServerAction","requestBody","secureMetadata","pMetadata","securedMetadata","Array","isArray","m","push","headers","customHttpHeaders","logOnServerAction","params","customHttpParams","responseType","httpResponseType","withCredentials","subscribe","serverCallsOutsideNgZone","runOutsideAngular","sendToServer","serverCallsBatchSize","serverCallsTimer","addLogToQueueAction","_","value","fq","NgZone","TOKEN_LOGGER_WRITER_SERVICE","NgxLoggerLevel","DEFAULT_COLOR_SCHEME","NGXLoggerWriterService","platformId","prepareMetaStringFuncs","getTimestampToWrite","getLevelToWrite","getFileDetailsToWrite","getContextToWrite","isIE","navigator","userAgent","match","logFunc","logIE","bind","logModern","disableFileDetails","context","prepareMetaString","metaString","prepareMetaStringFunc","metaItem","trim","getColor","configColorScheme","colorScheme","OFF","WARN","ERROR","FATAL","INFO","info","log","color","DEBUG","debug","writeMessage","args","NGXLogger","configEngineFactory","metadataService","ruleService","mapperService","writerService","serverService","configEngine","trace","_log","TRACE","LOG","fatal","setCustomHttpHeaders","getConfigSnapshot","setCustomParams","setWithCredentialsOptionValue","registerMonitor","monitor","_loggerMonitor","flushServerQueue","onLog","providedIn","CustomNGXLoggerService","logger","create","logMonitor","getNewInstance","LoggerModule","forRoot","customProvider","configProvider","provide","useValue","configEngineFactoryProvider","useClass","metadataProvider","ruleProvider","mapperProvider","writerProvider","serverProvider","ngModule","providers","forChild","ɵmod","ɵinj","imports"],"sources":["C:/Users/Ali Hamza/source/repos/ClassLibrary2/Web Api/ClientApp/node_modules/ngx-logger/fesm2020/ngx-logger.mjs"],"sourcesContent":["import * as i1 from '@angular/common/http';\nimport { HttpRequest, HttpResponse, HttpHeaders, HttpParams } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, PLATFORM_ID, Inject, NgModule } from '@angular/core';\nimport { of, BehaviorSubject, isObservable, throwError, timer } from 'rxjs';\nimport { filter, map, retry, shareReplay, catchError, concatMap, take } from 'rxjs/operators';\nimport * as vlq from 'vlq';\nimport * as i1$1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\n\n/**\r\n * Injection token of logger config\r\n */\r\nconst TOKEN_LOGGER_CONFIG = 'TOKEN_LOGGER_CONFIG';\n\nclass NGXLoggerConfigEngine {\r\n    constructor(config) {\r\n        this.config = this._clone(config);\r\n    }\r\n    /** Get a readonly access to the level configured for the NGXLogger */\r\n    get level() {\r\n        return this.config.level;\r\n    }\r\n    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n    get serverLogLevel() {\r\n        return this.config.serverLogLevel;\r\n    }\r\n    updateConfig(config) {\r\n        this.config = this._clone(config);\r\n    }\r\n    /** Update the config partially\r\n     * This is useful if you want to update only one parameter of the config\r\n     */\r\n    partialUpdateConfig(partialConfig) {\r\n        // avoid any error if the config is incorrect\r\n        if (!partialConfig) {\r\n            return;\r\n        }\r\n        Object.keys(partialConfig).forEach(configParamKey => {\r\n            this.config[configParamKey] = partialConfig[configParamKey];\r\n        });\r\n    }\r\n    getConfig() {\r\n        return this._clone(this.config);\r\n    }\r\n    // TODO: This is a shallow clone, If the config ever becomes hierarchical we must make this a deep clone\r\n    _clone(object) {\r\n        const cloneConfig = { level: null };\r\n        Object.keys(object).forEach((key) => {\r\n            cloneConfig[key] = object[key];\r\n        });\r\n        return cloneConfig;\r\n    }\r\n}\n\n/**\r\n * Injection token of logger config engine factory\r\n */\r\nconst TOKEN_LOGGER_CONFIG_ENGINE_FACTORY = 'TOKEN_LOGGER_CONFIG_ENGINE_FACTORY';\n\nclass NGXLoggerConfigEngineFactory {\r\n    provideConfigEngine(config) {\r\n        return new NGXLoggerConfigEngine(config);\r\n    }\r\n}\n\n/**\r\n * Injection token of logger mapper service\r\n */\r\nconst TOKEN_LOGGER_MAPPER_SERVICE = 'TOKEN_LOGGER_MAPPER_SERVICE';\n\nclass NGXLoggerMapperService {\r\n    constructor(httpBackend) {\r\n        this.httpBackend = httpBackend;\r\n        /** cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map' */\r\n        this.sourceMapCache = new Map();\r\n        /** cache for specific log position, key is the dist position, ie 'main.js:339:21' */\r\n        this.logPositionCache = new Map();\r\n    }\r\n    /**\r\n     * Returns the log position of the caller\r\n     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n     * @param config\r\n     * @param metadata\r\n     * @returns\r\n     */\r\n    getLogPosition(config, metadata) {\r\n        const stackLine = this.getStackLine(config);\r\n        // if we were not able to parse the stackLine, just return an empty Log Position\r\n        if (!stackLine) {\r\n            return of({ fileName: '', lineNumber: 0, columnNumber: 0 });\r\n        }\r\n        const logPosition = this.getLocalPosition(stackLine);\r\n        if (!config.enableSourceMaps) {\r\n            return of(logPosition);\r\n        }\r\n        const sourceMapLocation = this.getSourceMapLocation(stackLine);\r\n        return this.getSourceMap(sourceMapLocation, logPosition);\r\n    }\r\n    /**\r\n     * Get the stackline of the original caller\r\n     * @param config\r\n     * @returns null if stackline was not found\r\n     */\r\n    getStackLine(config) {\r\n        const error = new Error();\r\n        try {\r\n            // noinspection ExceptionCaughtLocallyJS\r\n            throw error;\r\n        }\r\n        catch (e) {\r\n            try {\r\n                // Here are different examples of stacktrace \r\n                // Firefox (last line is the user code, the 4 first are ours):\r\n                // getStackLine@http://localhost:4200/main.js:358:23\r\n                // getCallerDetails@http://localhost:4200/main.js:557:44\r\n                // _log@http://localhost:4200/main.js:830:28\r\n                // debug@http://localhost:4200/main.js:652:14\r\n                // handleLog@http://localhost:4200/main.js:1158:29\r\n                // Chrome and Edge (last line is the user code):\r\n                // Error\r\n                // at Function.getStackLine (ngx-logger.js:329)\r\n                // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\r\n                // at NGXLogger._log (ngx-logger.js:801)\r\n                // at NGXLogger.info (ngx-logger.js:631)\r\n                // at AppComponent.handleLog (app.component.ts:38)\r\n                let defaultProxy = 4; // We make 4 functions call before getting here\r\n                const firstStackLine = error.stack.split('\\n')[0];\r\n                if (!firstStackLine.includes('.js:')) {\r\n                    // The stacktrace starts with no function call (example in Chrome or Edge)\r\n                    defaultProxy = defaultProxy + 1;\r\n                }\r\n                return error.stack.split('\\n')[(defaultProxy + (config.proxiedSteps || 0))];\r\n            }\r\n            catch (e) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get position of caller without using sourceMaps\r\n     * @param stackLine\r\n     * @returns\r\n     */\r\n    getLocalPosition(stackLine) {\r\n        // strip base path, then parse filename, line, and column, stackline looks like this :\r\n        // Firefox\r\n        // handleLog@http://localhost:4200/main.js:1158:29\r\n        // Chrome and Edge\r\n        // at AppComponent.handleLog (app.component.ts:38)\r\n        const positionStartIndex = stackLine.lastIndexOf('\\/');\r\n        let positionEndIndex = stackLine.indexOf(')');\r\n        if (positionEndIndex < 0) {\r\n            positionEndIndex = undefined;\r\n        }\r\n        const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\r\n        const dataArray = position.split(':');\r\n        if (dataArray.length === 3) {\r\n            return { fileName: dataArray[0], lineNumber: +dataArray[1], columnNumber: +dataArray[2] };\r\n        }\r\n        return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n    }\r\n    getTranspileLocation(stackLine) {\r\n        // Example stackLine:\r\n        // Firefox : getStackLine@http://localhost:4200/main.js:358:23\r\n        // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\r\n        let locationStartIndex = stackLine.indexOf('(');\r\n        if (locationStartIndex < 0) {\r\n            locationStartIndex = stackLine.lastIndexOf('@');\r\n            if (locationStartIndex < 0) {\r\n                locationStartIndex = stackLine.lastIndexOf(' ');\r\n            }\r\n        }\r\n        let locationEndIndex = stackLine.indexOf(')');\r\n        if (locationEndIndex < 0) {\r\n            locationEndIndex = undefined;\r\n        }\r\n        return stackLine.substring(locationStartIndex + 1, locationEndIndex);\r\n    }\r\n    /**\r\n     * Gets the URL of the sourcemap (the URL can be relative or absolute, it is browser dependant)\r\n     * @param stackLine\r\n     * @returns\r\n     */\r\n    getSourceMapLocation(stackLine) {\r\n        const file = this.getTranspileLocation(stackLine);\r\n        const mapFullPath = file.substring(0, file.lastIndexOf(':'));\r\n        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\r\n    }\r\n    getMapping(sourceMap, position) {\r\n        // => ';' indicates end of a line\r\n        // => ',' separates mappings in a line\r\n        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\r\n        let sourceFileIndex = 0, // second field\r\n        sourceCodeLine = 0, // third field\r\n        sourceCodeColumn = 0; // fourth field\r\n        const lines = sourceMap.mappings.split(';');\r\n        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\r\n            // reset column position to 0 after each line\r\n            let generatedCodeColumn = 0;\r\n            // decode sections in line\r\n            const columns = lines[lineIndex].split(',');\r\n            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\r\n                const decodedSection = vlq.decode(columns[columnIndex]);\r\n                if (decodedSection.length >= 4) {\r\n                    // update relative positions\r\n                    generatedCodeColumn += decodedSection[0];\r\n                    sourceFileIndex += decodedSection[1];\r\n                    sourceCodeLine += decodedSection[2];\r\n                    sourceCodeColumn += decodedSection[3];\r\n                }\r\n                // check if matching map\r\n                if (lineIndex === position.lineNumber) {\r\n                    if (generatedCodeColumn === position.columnNumber) {\r\n                        // matching column and line found\r\n                        return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: sourceCodeColumn };\r\n                    }\r\n                    else if (columnIndex + 1 === columns.length) {\r\n                        // matching column not found, but line is correct\r\n                        return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: 0 };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // failed if reached\r\n        return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n    }\r\n    /**\r\n     * does the http get request to get the source map\r\n     * @param sourceMapLocation\r\n     * @param distPosition\r\n     */\r\n    getSourceMap(sourceMapLocation, distPosition) {\r\n        const req = new HttpRequest('GET', sourceMapLocation);\r\n        const distPositionKey = `${distPosition.fileName}:${distPosition.lineNumber}:${distPosition.columnNumber}`;\r\n        // if the specific log position is already in cache return it\r\n        if (this.logPositionCache.has(distPositionKey)) {\r\n            return this.logPositionCache.get(distPositionKey);\r\n        }\r\n        // otherwise check if the source map is already cached for given source map location\r\n        if (!this.sourceMapCache.has(sourceMapLocation)) {\r\n            if (!this.httpBackend) {\r\n                console.error('NGXLogger : Can\\'t get sourcemap because HttpBackend is not provided. You need to import HttpClientModule');\r\n                this.sourceMapCache.set(sourceMapLocation, of(null));\r\n            }\r\n            else {\r\n                // obtain the source map if not cached\r\n                this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter((e) => e instanceof HttpResponse), map((httpResponse) => httpResponse.body), retry(3), shareReplay(1)));\r\n            }\r\n        }\r\n        // at this point the source map is cached, use it to get specific log position mapping\r\n        const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map((sourceMap) => {\r\n            // sourceMap can be null if HttpBackend is not provided for example\r\n            if (!sourceMap) {\r\n                return distPosition;\r\n            }\r\n            // map generated position to source position\r\n            return this.getMapping(sourceMap, distPosition);\r\n        }), catchError(() => of(distPosition)), shareReplay(1));\r\n        // store specific log position in cache for given dest position and return it\r\n        this.logPositionCache.set(distPositionKey, logPosition$);\r\n        return logPosition$;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService, deps: [{ token: i1.HttpBackend, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1.HttpBackend, decorators: [{\r\n                    type: Optional\r\n                }] }]; } });\n\n/**\r\n * Injection token of logger metadata service\r\n */\r\nconst TOKEN_LOGGER_METADATA_SERVICE = 'TOKEN_LOGGER_METADATA_SERVICE';\n\nclass NGXLoggerMetadataService {\r\n    constructor(datePipe) {\r\n        this.datePipe = datePipe;\r\n    }\r\n    computeTimestamp(config) {\r\n        const defaultTimestamp = () => new Date().toISOString();\r\n        if (config.timestampFormat) {\r\n            if (!this.datePipe) {\r\n                console.error('NGXLogger : Can\\'t use timeStampFormat because DatePipe is not provided. You need to provide DatePipe');\r\n                return defaultTimestamp();\r\n            }\r\n            else {\r\n                return this.datePipe.transform(new Date(), config.timestampFormat);\r\n            }\r\n        }\r\n        return defaultTimestamp();\r\n    }\r\n    getMetadata(level, config, message, additional) {\r\n        const metadata = {\r\n            level: level,\r\n            additional: additional,\r\n        };\r\n        // The user can send a function\r\n        // This is useful in order to compute string concatenation only when the log will actually be written\r\n        if (message && typeof message === 'function') {\r\n            metadata.message = message();\r\n        }\r\n        else {\r\n            metadata.message = message;\r\n        }\r\n        metadata.timestamp = this.computeTimestamp(config);\r\n        return metadata;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService, deps: [{ token: i1$1.DatePipe, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1$1.DatePipe, decorators: [{\r\n                    type: Optional\r\n                }] }]; } });\n\n// I kept this class alive only to avoid a breaking change with the old version\r\n// This class does not implement anything so it is useless and the interface is enough\r\n/**\r\n * @deprecated this class does not implement anything thus being useless, you should rather implements @see INGXLoggerMonitor\r\n */\r\nclass NGXLoggerMonitor {\r\n}\n\n/**\r\n * Injection token of logger metadata service\r\n */\r\nconst TOKEN_LOGGER_RULES_SERVICE = 'TOKEN_LOGGER_RULES_SERVICE';\n\nclass NGXLoggerRulesService {\r\n    shouldCallWriter(level, config, message, additional) {\r\n        return !config.disableConsoleLogging && level >= config.level;\r\n    }\r\n    shouldCallServer(level, config, message, additional) {\r\n        return !!config.serverLoggingUrl && level >= config.serverLogLevel;\r\n    }\r\n    shouldCallMonitor(level, config, message, additional) {\r\n        // The default behavior is to call the monitor only if the writer or the server is called\r\n        return this.shouldCallWriter(level, config, message, additional) || this.shouldCallServer(level, config, message, additional);\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n/**\r\n * Injection token of logger server service\r\n */\r\nconst TOKEN_LOGGER_SERVER_SERVICE = 'TOKEN_LOGGER_SERVER_SERVICE';\n\nclass NGXLoggerServerService {\r\n    constructor(httpBackend, ngZone) {\r\n        this.httpBackend = httpBackend;\r\n        this.ngZone = ngZone;\r\n        this.serverCallsQueue = [];\r\n        this.flushingQueue = new BehaviorSubject(false);\r\n    }\r\n    ngOnDestroy() {\r\n        if (this.flushingQueue) {\r\n            this.flushingQueue.complete();\r\n            this.flushingQueue = null;\r\n        }\r\n        if (this.addToQueueTimer) {\r\n            this.addToQueueTimer.unsubscribe();\r\n            this.addToQueueTimer = null;\r\n        }\r\n    }\r\n    /**\r\n     * Transforms an error object into a readable string (taking only the stack)\r\n     * This is needed because JSON.stringify would return \"{}\"\r\n     * @param err the error object\r\n     * @returns The stack of the error\r\n     */\r\n    secureErrorObject(err) {\r\n        return err?.stack;\r\n    }\r\n    /**\r\n     * Transforms the additional parameters to avoid any json error when sending the data to the server\r\n     * Basically it just replaces unstringifiable object to a string mentioning an error\r\n     * @param additional The additional data to be sent\r\n     * @returns The additional data secured\r\n     */\r\n    secureAdditionalParameters(additional) {\r\n        if (additional === null || additional === undefined) {\r\n            return null;\r\n        }\r\n        return additional.map((next, idx) => {\r\n            try {\r\n                if (next instanceof Error) {\r\n                    return this.secureErrorObject(next);\r\n                }\r\n                // We just want to make sure the JSON can be parsed, we do not want to actually change the type\r\n                if (typeof next === 'object') {\r\n                    JSON.stringify(next);\r\n                }\r\n                return next;\r\n            }\r\n            catch (e) {\r\n                return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Transforms the message so that it can be sent to the server\r\n     * @param message the message to be sent\r\n     * @returns the message secured\r\n     */\r\n    secureMessage(message) {\r\n        try {\r\n            if (message instanceof Error) {\r\n                return this.secureErrorObject(message);\r\n            }\r\n            if (typeof message !== 'string') {\r\n                message = JSON.stringify(message, null, 2);\r\n            }\r\n        }\r\n        catch (e) {\r\n            message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\r\n        }\r\n        return message;\r\n    }\r\n    /**\r\n     * Edits HttpRequest object before sending request to server\r\n     * @param httpRequest default request object\r\n     * @returns altered httprequest\r\n     */\r\n    alterHttpRequest(httpRequest) {\r\n        return httpRequest;\r\n    }\r\n    /**\r\n     * Sends request to server\r\n     * @param url\r\n     * @param logContent\r\n     * @param options\r\n     * @returns\r\n     */\r\n    logOnServer(url, logContent, options) {\r\n        if (!this.httpBackend) {\r\n            console.error('NGXLogger : Can\\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');\r\n            return of(null);\r\n        }\r\n        // HttpBackend skips all HttpInterceptors\r\n        // They may log errors using this service causing circular calls\r\n        let defaultRequest = new HttpRequest('POST', url, logContent, options || {});\r\n        let finalRequest = of(defaultRequest);\r\n        const alteredRequest = this.alterHttpRequest(defaultRequest);\r\n        if (isObservable(alteredRequest)) {\r\n            finalRequest = alteredRequest;\r\n        }\r\n        else if (alteredRequest) {\r\n            finalRequest = of(alteredRequest);\r\n        }\r\n        else {\r\n            console.warn('NGXLogger : alterHttpRequest returned an invalid request. Using default one instead');\r\n        }\r\n        return finalRequest.pipe(concatMap(req => {\r\n            if (!req) {\r\n                console.warn('NGXLogger : alterHttpRequest returned an invalid request (observable). Using default one instead');\r\n                return this.httpBackend.handle(defaultRequest);\r\n            }\r\n            return this.httpBackend.handle(req);\r\n        }), filter(e => e instanceof HttpResponse), map((httpResponse) => httpResponse.body));\r\n    }\r\n    /**\r\n     * Customise the data sent to the API\r\n     * @param metadata the data provided by NGXLogger\r\n     * @returns the data that will be sent to the API in the body\r\n     */\r\n    customiseRequestBody(metadata) {\r\n        // In our API the body is not customised\r\n        return metadata;\r\n    }\r\n    /**\r\n     * Flush the queue of the logger\r\n     * @param config\r\n     */\r\n    flushQueue(config) {\r\n        this.flushingQueue.next(true);\r\n        // If a timer was set, we cancel it because the queue is flushed\r\n        if (this.addToQueueTimer) {\r\n            this.addToQueueTimer.unsubscribe();\r\n            this.addToQueueTimer = null;\r\n        }\r\n        if (!!this.serverCallsQueue && this.serverCallsQueue.length > 0) {\r\n            this.sendToServerAction(this.serverCallsQueue, config);\r\n        }\r\n        this.serverCallsQueue = [];\r\n        this.flushingQueue.next(false);\r\n    }\r\n    sendToServerAction(metadata, config) {\r\n        let requestBody;\r\n        const secureMetadata = (pMetadata) => {\r\n            // Copying metadata locally because we don't want to change the object for the caller\r\n            const securedMetadata = { ...pMetadata };\r\n            securedMetadata.additional = this.secureAdditionalParameters(securedMetadata.additional);\r\n            securedMetadata.message = this.secureMessage(securedMetadata.message);\r\n            return securedMetadata;\r\n        };\r\n        if (Array.isArray(metadata)) {\r\n            requestBody = [];\r\n            metadata.forEach(m => {\r\n                requestBody.push(secureMetadata(m));\r\n            });\r\n        }\r\n        else {\r\n            requestBody = secureMetadata(metadata);\r\n        }\r\n        // Allow users to customise the data sent to the API\r\n        requestBody = this.customiseRequestBody(requestBody);\r\n        const headers = config.customHttpHeaders || new HttpHeaders();\r\n        if (!headers.has('Content-Type')) {\r\n            headers.set('Content-Type', 'application/json');\r\n        }\r\n        const logOnServerAction = () => {\r\n            this.logOnServer(config.serverLoggingUrl, requestBody, {\r\n                headers,\r\n                params: config.customHttpParams || new HttpParams(),\r\n                responseType: config.httpResponseType || 'json',\r\n                withCredentials: config.withCredentials || false,\r\n            }).pipe(catchError(err => {\r\n                // Do not use NGXLogger here because this could cause an infinite loop \r\n                console.error('NGXLogger: Failed to log on server', err);\r\n                return throwError(err);\r\n            })).subscribe();\r\n        };\r\n        if (config.serverCallsOutsideNgZone === true) {\r\n            if (!this.ngZone) {\r\n                console.error('NGXLogger: NgZone is not provided and serverCallsOutsideNgZone is set to true');\r\n                return;\r\n            }\r\n            this.ngZone.runOutsideAngular(logOnServerAction);\r\n        }\r\n        else {\r\n            logOnServerAction();\r\n        }\r\n    }\r\n    /**\r\n     * Sends the content to be logged to the server according to the config\r\n     * @param metadata\r\n     * @param config\r\n     */\r\n    sendToServer(metadata, config) {\r\n        // If there is no batch mode in the config, we send the log call straight to the server as usual\r\n        if ((!config.serverCallsBatchSize || config.serverCallsBatchSize <= 0) &&\r\n            (!config.serverCallsTimer || config.serverCallsTimer <= 0)) {\r\n            this.sendToServerAction(metadata, config);\r\n            return;\r\n        }\r\n        const addLogToQueueAction = () => {\r\n            this.serverCallsQueue.push({ ...metadata });\r\n            // Flush queue when size is reached\r\n            if (!!config.serverCallsBatchSize && this.serverCallsQueue.length > config.serverCallsBatchSize) {\r\n                this.flushQueue(config);\r\n            }\r\n            // Call timer only if it is in the config and timer is not already running\r\n            if (config.serverCallsTimer > 0 && !this.addToQueueTimer) {\r\n                this.addToQueueTimer = timer(config.serverCallsTimer).subscribe(_ => {\r\n                    this.flushQueue(config);\r\n                });\r\n            }\r\n        };\r\n        // If queue is being flushed, we need to wait for it to finish before adding other calls\r\n        if (this.flushingQueue.value === true) {\r\n            this.flushingQueue.pipe(filter(fq => fq === false), take(1)).subscribe(_ => {\r\n                addLogToQueueAction();\r\n            });\r\n        }\r\n        else {\r\n            addLogToQueueAction();\r\n        }\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService, deps: [{ token: i1.HttpBackend, optional: true }, { token: i0.NgZone, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1.HttpBackend, decorators: [{\r\n                    type: Optional\r\n                }] }, { type: i0.NgZone, decorators: [{\r\n                    type: Optional\r\n                }] }]; } });\n\n/**\r\n * Injection token of logger writer service\r\n */\r\nconst TOKEN_LOGGER_WRITER_SERVICE = 'TOKEN_LOGGER_WRITER_SERVICE';\n\nvar NgxLoggerLevel;\r\n(function (NgxLoggerLevel) {\r\n    NgxLoggerLevel[NgxLoggerLevel[\"TRACE\"] = 0] = \"TRACE\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"DEBUG\"] = 1] = \"DEBUG\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"INFO\"] = 2] = \"INFO\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"LOG\"] = 3] = \"LOG\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"WARN\"] = 4] = \"WARN\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"ERROR\"] = 5] = \"ERROR\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"FATAL\"] = 6] = \"FATAL\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"OFF\"] = 7] = \"OFF\";\r\n})(NgxLoggerLevel || (NgxLoggerLevel = {}));\n\nconst DEFAULT_COLOR_SCHEME = [\r\n    'purple',\r\n    'teal',\r\n    'gray',\r\n    'gray',\r\n    'red',\r\n    'red',\r\n    'red'\r\n];\n\nclass NGXLoggerWriterService {\r\n    constructor(platformId) {\r\n        this.platformId = platformId;\r\n        /** List of functions called when preparing meta string */\r\n        this.prepareMetaStringFuncs = [\r\n            this.getTimestampToWrite,\r\n            this.getLevelToWrite,\r\n            this.getFileDetailsToWrite,\r\n            this.getContextToWrite,\r\n        ];\r\n        this.isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent &&\r\n            !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\r\n        this.logFunc = this.isIE ? this.logIE.bind(this) : this.logModern.bind(this);\r\n    }\r\n    getTimestampToWrite(metadata, config) {\r\n        return metadata.timestamp;\r\n    }\r\n    getLevelToWrite(metadata, config) {\r\n        return NgxLoggerLevel[metadata.level];\r\n    }\r\n    getFileDetailsToWrite(metadata, config) {\r\n        return config.disableFileDetails === true ? '' : `[${metadata.fileName}:${metadata.lineNumber}:${metadata.columnNumber}]`;\r\n    }\r\n    getContextToWrite(metadata, config) {\r\n        return config.context ? `{${config.context}}` : '';\r\n    }\r\n    /** Generate a \"meta\" string that is displayed before the content sent to the log function */\r\n    prepareMetaString(metadata, config) {\r\n        let metaString = '';\r\n        this.prepareMetaStringFuncs.forEach(prepareMetaStringFunc => {\r\n            const metaItem = prepareMetaStringFunc(metadata, config);\r\n            if (metaItem) {\r\n                metaString = metaString + ' ' + metaItem;\r\n            }\r\n        });\r\n        return metaString.trim();\r\n    }\r\n    /** Get the color to use when writing to console */\r\n    getColor(metadata, config) {\r\n        const configColorScheme = config.colorScheme ?? DEFAULT_COLOR_SCHEME;\r\n        // this is needed to avoid a build error\r\n        if (metadata.level === NgxLoggerLevel.OFF) {\r\n            return undefined;\r\n        }\r\n        return configColorScheme[metadata.level];\r\n    }\r\n    /** Log to the console specifically for IE */\r\n    logIE(metadata, config, metaString) {\r\n        // Coloring doesn't work in IE\r\n        // make sure additional isn't null or undefined so that ...additional doesn't error\r\n        const additional = metadata.additional || [];\r\n        switch (metadata.level) {\r\n            case NgxLoggerLevel.WARN:\r\n                console.warn(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.ERROR:\r\n            case NgxLoggerLevel.FATAL:\r\n                console.error(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.INFO:\r\n                console.info(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            default:\r\n                console.log(`${metaString} `, metadata.message, ...additional);\r\n        }\r\n    }\r\n    /** Log to the console */\r\n    logModern(metadata, config, metaString) {\r\n        const color = this.getColor(metadata, config);\r\n        // make sure additional isn't null or undefined so that ...additional doesn't error\r\n        const additional = metadata.additional || [];\r\n        switch (metadata.level) {\r\n            case NgxLoggerLevel.WARN:\r\n                console.warn(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.ERROR:\r\n            case NgxLoggerLevel.FATAL:\r\n                console.error(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.INFO:\r\n                console.info(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\r\n            // the console.trace statement\r\n            // case NgxLoggerLevel.TRACE:\r\n            //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n            //   break;\r\n            case NgxLoggerLevel.DEBUG:\r\n                console.debug(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            default:\r\n                console.log(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n        }\r\n    }\r\n    /** Write the content sent to the log function to the console */\r\n    writeMessage(metadata, config) {\r\n        const metaString = this.prepareMetaString(metadata, config);\r\n        this.logFunc(metadata, config, metaString);\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [PLATFORM_ID]\r\n                }] }]; } });\n\nclass NGXLogger {\r\n    constructor(config, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\r\n        this.metadataService = metadataService;\r\n        this.ruleService = ruleService;\r\n        this.mapperService = mapperService;\r\n        this.writerService = writerService;\r\n        this.serverService = serverService;\r\n        this.configEngine = configEngineFactory.provideConfigEngine(config);\r\n    }\r\n    /** Get a readonly access to the level configured for the NGXLogger */\r\n    get level() {\r\n        return this.configEngine.level;\r\n    }\r\n    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n    get serverLogLevel() {\r\n        return this.configEngine.serverLogLevel;\r\n    }\r\n    trace(message, ...additional) {\r\n        this._log(NgxLoggerLevel.TRACE, message, additional);\r\n    }\r\n    debug(message, ...additional) {\r\n        this._log(NgxLoggerLevel.DEBUG, message, additional);\r\n    }\r\n    info(message, ...additional) {\r\n        this._log(NgxLoggerLevel.INFO, message, additional);\r\n    }\r\n    log(message, ...additional) {\r\n        this._log(NgxLoggerLevel.LOG, message, additional);\r\n    }\r\n    warn(message, ...additional) {\r\n        this._log(NgxLoggerLevel.WARN, message, additional);\r\n    }\r\n    error(message, ...additional) {\r\n        this._log(NgxLoggerLevel.ERROR, message, additional);\r\n    }\r\n    fatal(message, ...additional) {\r\n        this._log(NgxLoggerLevel.FATAL, message, additional);\r\n    }\r\n    /** @deprecated customHttpHeaders is now part of the config, this should be updated via @see updateConfig */\r\n    setCustomHttpHeaders(headers) {\r\n        const config = this.getConfigSnapshot();\r\n        config.customHttpHeaders = headers;\r\n        this.updateConfig(config);\r\n    }\r\n    /** @deprecated customHttpParams is now part of the config, this should be updated via @see updateConfig */\r\n    setCustomParams(params) {\r\n        const config = this.getConfigSnapshot();\r\n        config.customHttpParams = params;\r\n        this.updateConfig(config);\r\n    }\r\n    /** @deprecated withCredentials is now part of the config, this should be updated via @see updateConfig */\r\n    setWithCredentialsOptionValue(withCredentials) {\r\n        const config = this.getConfigSnapshot();\r\n        config.withCredentials = withCredentials;\r\n        this.updateConfig(config);\r\n    }\r\n    /**\r\n     * Register a INGXLoggerMonitor that will be trigger when a log is either written or sent to server\r\n     *\r\n     * There is only one monitor, registering one will overwrite the last one if there was one\r\n     * @param monitor\r\n     */\r\n    registerMonitor(monitor) {\r\n        this._loggerMonitor = monitor;\r\n    }\r\n    /** Set config of logger\r\n     *\r\n     * Warning : This overwrites all the config, if you want to update only one property, you should use @see getConfigSnapshot before\r\n     */\r\n    updateConfig(config) {\r\n        this.configEngine.updateConfig(config);\r\n    }\r\n    partialUpdateConfig(partialConfig) {\r\n        this.configEngine.partialUpdateConfig(partialConfig);\r\n    }\r\n    /** Get config of logger */\r\n    getConfigSnapshot() {\r\n        return this.configEngine.getConfig();\r\n    }\r\n    /**\r\n     * Flush the serveur queue\r\n     */\r\n    flushServerQueue() {\r\n        this.serverService.flushQueue(this.getConfigSnapshot());\r\n    }\r\n    _log(level, message, additional = []) {\r\n        const config = this.configEngine.getConfig();\r\n        const shouldCallWriter = this.ruleService.shouldCallWriter(level, config, message, additional);\r\n        const shouldCallServer = this.ruleService.shouldCallServer(level, config, message, additional);\r\n        const shouldCallMonitor = this.ruleService.shouldCallMonitor(level, config, message, additional);\r\n        if (!shouldCallWriter && !shouldCallServer && !shouldCallMonitor) {\r\n            // If nothing is to be called we return\r\n            return;\r\n        }\r\n        const metadata = this.metadataService.getMetadata(level, config, message, additional);\r\n        this.mapperService.getLogPosition(config, metadata).pipe(take(1)).subscribe(logPosition => {\r\n            if (logPosition) {\r\n                metadata.fileName = logPosition.fileName;\r\n                metadata.lineNumber = logPosition.lineNumber;\r\n                metadata.columnNumber = logPosition.columnNumber;\r\n            }\r\n            if (shouldCallMonitor && this._loggerMonitor) {\r\n                this._loggerMonitor.onLog(metadata, config);\r\n            }\r\n            if (shouldCallWriter) {\r\n                this.writerService.writeMessage(metadata, config);\r\n            }\r\n            if (shouldCallServer) {\r\n                this.serverService.sendToServer(metadata, config);\r\n            }\r\n        });\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLogger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, deps: [{ token: TOKEN_LOGGER_CONFIG }, { token: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY }, { token: TOKEN_LOGGER_METADATA_SERVICE }, { token: TOKEN_LOGGER_RULES_SERVICE }, { token: TOKEN_LOGGER_MAPPER_SERVICE }, { token: TOKEN_LOGGER_WRITER_SERVICE }, { token: TOKEN_LOGGER_SERVER_SERVICE }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLogger.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_CONFIG]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_METADATA_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_RULES_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_MAPPER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_WRITER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_SERVER_SERVICE]\r\n                }] }]; } });\n\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n */\r\nclass CustomNGXLoggerService {\r\n    constructor(logger, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\r\n        this.logger = logger;\r\n        this.configEngineFactory = configEngineFactory;\r\n        this.metadataService = metadataService;\r\n        this.ruleService = ruleService;\r\n        this.mapperService = mapperService;\r\n        this.writerService = writerService;\r\n        this.serverService = serverService;\r\n    }\r\n    /**\r\n     * Create an instance of a logger\r\n     * @deprecated this function does not have all the features, @see getNewInstance for every params available\r\n     * @param config\r\n     * @param serverService\r\n     * @param logMonitor\r\n     * @param mapperService\r\n     * @returns\r\n     */\r\n    create(config, serverService, logMonitor, mapperService) {\r\n        return this.getNewInstance({\r\n            config,\r\n            serverService,\r\n            logMonitor,\r\n            mapperService\r\n        });\r\n    }\r\n    /**\r\n     * Get a new instance of NGXLogger\r\n     * @param params list of optional params to use when creating an instance of NGXLogger\r\n     * @returns the new instance of NGXLogger\r\n     */\r\n    getNewInstance(params) {\r\n        const logger = new NGXLogger(params?.config ?? this.logger.getConfigSnapshot(), params?.configEngineFactory ?? this.configEngineFactory, params?.metadataService ?? this.metadataService, params?.ruleService ?? this.ruleService, params?.mapperService ?? this.mapperService, params?.writerService ?? this.writerService, params?.serverService ?? this.serverService);\r\n        if (params?.partialConfig) {\r\n            logger.partialUpdateConfig(params.partialConfig);\r\n        }\r\n        if (params?.logMonitor) {\r\n            logger.registerMonitor(params.logMonitor);\r\n        }\r\n        return logger;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, deps: [{ token: NGXLogger }, { token: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY }, { token: TOKEN_LOGGER_METADATA_SERVICE }, { token: TOKEN_LOGGER_RULES_SERVICE }, { token: TOKEN_LOGGER_MAPPER_SERVICE }, { token: TOKEN_LOGGER_WRITER_SERVICE }, { token: TOKEN_LOGGER_SERVER_SERVICE }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: NGXLogger }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_METADATA_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_RULES_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_MAPPER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_WRITER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_SERVER_SERVICE]\r\n                }] }]; } });\n\nclass LoggerModule {\r\n    static forRoot(config, customProvider) {\r\n        if (!customProvider) {\r\n            customProvider = {};\r\n        }\r\n        // default config provider\r\n        if (!customProvider.configProvider) {\r\n            customProvider.configProvider = { provide: TOKEN_LOGGER_CONFIG, useValue: config || {} };\r\n        }\r\n        else {\r\n            // if the user provided its own config, we just make sure the injection token is correct\r\n            if (customProvider.configProvider.provide !== TOKEN_LOGGER_CONFIG) {\r\n                throw new Error(`Wrong injection token for configProvider, it should be ${TOKEN_LOGGER_CONFIG} and you used ${customProvider.configProvider.provide}`);\r\n            }\r\n        }\r\n        // default configEngine provider\r\n        if (!customProvider.configEngineFactoryProvider) {\r\n            customProvider.configEngineFactoryProvider = { provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, useClass: NGXLoggerConfigEngineFactory };\r\n        }\r\n        else {\r\n            // if the user provided its own configEngineFactory, we just make sure the injection token is correct\r\n            if (customProvider.configEngineFactoryProvider.provide !== TOKEN_LOGGER_CONFIG_ENGINE_FACTORY) {\r\n                throw new Error(`Wrong injection token for configEngineFactoryProvider, it should be '${TOKEN_LOGGER_CONFIG_ENGINE_FACTORY}' and you used '${customProvider.configEngineFactoryProvider.provide}'`);\r\n            }\r\n        }\r\n        // default metadata provider\r\n        if (!customProvider.metadataProvider) {\r\n            customProvider.metadataProvider = { provide: TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataService };\r\n        }\r\n        else {\r\n            // if the user provided its own metadataService, we just make sure the injection token is correct\r\n            if (customProvider.metadataProvider.provide !== TOKEN_LOGGER_METADATA_SERVICE) {\r\n                throw new Error(`Wrong injection token for metadataProvider, it should be '${TOKEN_LOGGER_METADATA_SERVICE}' and you used '${customProvider.metadataProvider.provide}'`);\r\n            }\r\n        }\r\n        // default rule provider\r\n        if (!customProvider.ruleProvider) {\r\n            customProvider.ruleProvider = { provide: TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesService };\r\n        }\r\n        else {\r\n            // if the user provided its own ruleService, we just make sure the injection token is correct\r\n            if (customProvider.ruleProvider.provide !== TOKEN_LOGGER_RULES_SERVICE) {\r\n                throw new Error(`Wrong injection token for ruleProvider, it should be '${TOKEN_LOGGER_RULES_SERVICE}' and you used '${customProvider.ruleProvider.provide}'`);\r\n            }\r\n        }\r\n        // default mapper provider\r\n        if (!customProvider.mapperProvider) {\r\n            customProvider.mapperProvider = { provide: TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperService };\r\n        }\r\n        else {\r\n            // if the user provided its own mapperService, we just make sure the injection token is correct\r\n            if (customProvider.mapperProvider.provide !== TOKEN_LOGGER_MAPPER_SERVICE) {\r\n                throw new Error(`Wrong injection token for mapperProvider, it should be '${TOKEN_LOGGER_MAPPER_SERVICE}' and you used '${customProvider.mapperProvider.provide}'`);\r\n            }\r\n        }\r\n        // default writer provider\r\n        if (!customProvider.writerProvider) {\r\n            customProvider.writerProvider = { provide: TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterService };\r\n        }\r\n        else {\r\n            // if the user provided its own writerService, we just make sure the injection token is correct\r\n            if (customProvider.writerProvider.provide !== TOKEN_LOGGER_WRITER_SERVICE) {\r\n                throw new Error(`Wrong injection token for writerProvider, it should be '${TOKEN_LOGGER_WRITER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n            }\r\n        }\r\n        // default server provider\r\n        if (!customProvider.serverProvider) {\r\n            customProvider.serverProvider = { provide: TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerService };\r\n        }\r\n        else {\r\n            // if the user provided its own serverService, we just make sure the injection token is correct\r\n            if (customProvider.serverProvider.provide !== TOKEN_LOGGER_SERVER_SERVICE) {\r\n                throw new Error(`Wrong injection token for serverProvider, it should be '${TOKEN_LOGGER_SERVER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n            }\r\n        }\r\n        return {\r\n            ngModule: LoggerModule,\r\n            providers: [\r\n                NGXLogger,\r\n                customProvider.configProvider,\r\n                customProvider.configEngineFactoryProvider,\r\n                customProvider.metadataProvider,\r\n                customProvider.ruleProvider,\r\n                customProvider.mapperProvider,\r\n                customProvider.writerProvider,\r\n                customProvider.serverProvider,\r\n                CustomNGXLoggerService,\r\n            ]\r\n        };\r\n    }\r\n    static forChild() {\r\n        // todo : this forChild is useless for now because nothing is different from forRoot.\r\n        // This should be implemented so that user can change the providers in the forChild\r\n        return {\r\n            ngModule: LoggerModule,\r\n        };\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, imports: [CommonModule] });\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, imports: [[\r\n            CommonModule\r\n        ]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [\r\n                        CommonModule\r\n                    ],\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of ngx-logger\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, LoggerModule, NGXLogger, NGXLoggerConfigEngine, NGXLoggerConfigEngineFactory, NGXLoggerMapperService, NGXLoggerMetadataService, NGXLoggerMonitor, NGXLoggerRulesService, NGXLoggerServerService, NGXLoggerWriterService, NgxLoggerLevel, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}